From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Peter=20G=C3=BCttinger?= <njol@gmx.ch>
Date: Sat, 18 Feb 2023 10:18:50 +0100
Subject: [PATCH] Monumenta: added the 'run' command and code blocks


diff --git a/src/main/java/net/minecraft/commands/CommandFunction.java b/src/main/java/net/minecraft/commands/CommandFunction.java
index a89e2865f8db2fd13bb37c19f3abf8f772ff90ef..baf69fc0585ff233b4aeba5b764608aa283d90c7 100644
--- a/src/main/java/net/minecraft/commands/CommandFunction.java
+++ b/src/main/java/net/minecraft/commands/CommandFunction.java
@@ -45,6 +45,30 @@ public class CommandFunction {
         for(int i = 0; i < lines.size(); ++i) {
             int j = i + 1;
             String string = lines.get(i).trim();
+			// Monumenta start: code blocks
+			if (string.startsWith("run ") && string.endsWith("{")) {
+				boolean first = true;
+				int nesting = 1;
+		        for (i++; i < lines.size(); i++) {
+					String blockLine = lines.get(i);
+					String blockLineTrimmed = blockLine.trim();
+					string += (first ? " " : "\n") + blockLine;
+					first = false;
+					if (blockLineTrimmed.equals("}")) {
+						nesting--;
+						if (nesting == 0) {
+							break;
+						}
+					} else if (blockLineTrimmed.startsWith("run ") && blockLineTrimmed.endsWith("{")) {
+						nesting++;
+					}
+		        }
+				if (nesting != 0) {
+                    throw new IllegalArgumentException("Unterminated block starting at line " + j);
+				}
+                j = i + 1;
+			}
+			// Monumenta end
             StringReader stringReader = new StringReader(string);
             if (stringReader.canRead() && stringReader.peek() != '#') {
                 if (stringReader.peek() == '/') {
@@ -65,7 +89,7 @@ public class CommandFunction {
 
                     list.add(new CommandFunction.CommandEntry(parseResults));
                 } catch (CommandSyntaxException var10) {
-                    throw new IllegalArgumentException("Whilst parsing command on line " + j + ": " + var10.getMessage());
+                    throw new IllegalArgumentException("Whilst parsing command on line " + j + ": " + var10.getMessage() + " (full line: '" + string + "')");
                 }
             }
         }
diff --git a/src/main/java/net/minecraft/commands/Commands.java b/src/main/java/net/minecraft/commands/Commands.java
index b66afde6851ceaeccb84aea00cdc333dfbf3d4b0..83f6c485475af8fa03aa82ebaa20ca9b9d18be6f 100644
--- a/src/main/java/net/minecraft/commands/Commands.java
+++ b/src/main/java/net/minecraft/commands/Commands.java
@@ -213,6 +213,9 @@ public class Commands {
             PublishCommand.register(this.dispatcher);
         }
 
+		// Monumenta
+        net.minecraft.server.commands.RunCommand.register(this.dispatcher);
+
         // Paper start
         for (final CommandNode<CommandSourceStack> node : this.dispatcher.getRoot().getChildren()) {
             if (node.getRequirement() == com.mojang.brigadier.builder.ArgumentBuilder.<CommandSourceStack>defaultRequirement()) {
diff --git a/src/main/java/net/minecraft/commands/arguments/CodeBlockArgument.java b/src/main/java/net/minecraft/commands/arguments/CodeBlockArgument.java
new file mode 100644
index 0000000000000000000000000000000000000000..8e6b5f44b486105ba4e7f390e78f476896eb1a28
--- /dev/null
+++ b/src/main/java/net/minecraft/commands/arguments/CodeBlockArgument.java
@@ -0,0 +1,56 @@
+package net.minecraft.commands.arguments;
+
+import com.mojang.brigadier.CommandDispatcher;
+import com.mojang.brigadier.StringReader;
+import com.mojang.brigadier.arguments.ArgumentType;
+import com.mojang.brigadier.context.CommandContext;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
+import java.util.Arrays;
+import net.minecraft.commands.CommandFunction;
+import net.minecraft.commands.CommandSource;
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.network.chat.TextComponent;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.world.phys.Vec2;
+import net.minecraft.world.phys.Vec3;
+
+// Monumenta: added this argument
+public class CodeBlockArgument implements ArgumentType<CommandFunction> {
+
+	@Override
+	public CommandFunction parse(StringReader reader) throws CommandSyntaxException {
+		CommandDispatcher<CommandSourceStack> dispatcher = MinecraftServer.getServer().getCommands().getDispatcher();
+		// context copied from ServerFunctionLibrary
+		CommandSourceStack commandSourceStack = new CommandSourceStack(CommandSource.NULL, Vec3.ZERO, Vec2.ZERO, null, MinecraftServer.getServer().getFunctionCompilationLevel(), "", TextComponent.EMPTY, null, null);
+
+		StringBuilder linesBuilder = new StringBuilder();
+		while (reader.canRead()) {
+			linesBuilder.append(reader.read());
+		}
+		String lines = linesBuilder.toString().replaceFirst("}\\s*$", "");
+
+		try {
+			CommandFunction f = CommandFunction.fromLines(new ResourceLocation("minecraft", "synthetic-run-function"), dispatcher, commandSourceStack, Arrays.asList(lines.split("\n")));
+			System.out.println(f);
+			return f;
+		} catch (IllegalArgumentException e) {
+			System.out.println(e);
+			throw new CommandSyntaxException(new SimpleCommandExceptionType(new TextComponent("Error in code block")), new TextComponent("Error in code block: " + e.getMessage()));
+		} catch (Exception e) {
+			System.out.println(e);
+			throw e;
+		}
+
+	}
+
+	public static CodeBlockArgument codeBlock() {
+		return new CodeBlockArgument();
+	}
+
+	public static CommandFunction getCodeBlock(CommandContext<CommandSourceStack> context, String name) {
+		return context.getArgument(name, CommandFunction.class);
+	}
+
+}
diff --git a/src/main/java/net/minecraft/commands/synchronization/ArgumentTypes.java b/src/main/java/net/minecraft/commands/synchronization/ArgumentTypes.java
index c2302b2a9007da01a821c26bc29b7c6db5662247..cbc2d1f792ea36666384688a8ef99e2b5f274728 100644
--- a/src/main/java/net/minecraft/commands/synchronization/ArgumentTypes.java
+++ b/src/main/java/net/minecraft/commands/synchronization/ArgumentTypes.java
@@ -130,7 +130,7 @@ public class ArgumentTypes {
     }
 
     private static <T extends ArgumentType<?>> Class<T> fixClassType(Class<? super T> clazz) {
-        return clazz;
+        return (Class<T>) clazz;
     }
 
     @Nullable
@@ -144,9 +144,10 @@ public class ArgumentTypes {
     }
 
     public static <T extends ArgumentType<?>> void serialize(FriendlyByteBuf buf, T type) {
-        ArgumentTypes.Entry<T> entry = get(type);
+        ArgumentTypes.Entry<T> entry = (Entry<T>) get(type);
         if (entry == null) {
-            LOGGER.error("Could not serialize {} ({}) - will not be sent to client!", type, type.getClass());
+            // Monumenta: custom argument types cannot be serialized - don't log an error for them
+            // LOGGER.error("Could not serialize {} ({}) - will not be sent to client!", type, type.getClass());
             buf.writeResourceLocation(new ResourceLocation(""));
         } else {
             buf.writeResourceLocation(entry.name);
@@ -167,7 +168,7 @@ public class ArgumentTypes {
     }
 
     private static <T extends ArgumentType<?>> void serializeToJson(JsonObject json, T type) {
-        ArgumentTypes.Entry<T> entry = get(type);
+        ArgumentTypes.Entry<T> entry = (Entry<T>) get(type);
         if (entry == null) {
             LOGGER.error("Could not serialize argument {} ({})!", type, type.getClass());
             json.addProperty("type", "unknown");
diff --git a/src/main/java/net/minecraft/server/commands/ExecuteCommand.java b/src/main/java/net/minecraft/server/commands/ExecuteCommand.java
index 818596eda9488b98f7b80c6e9d81ccbf6512f488..643fe90b40463a75a1290a1f3649e40fe5f6ecd0 100644
--- a/src/main/java/net/minecraft/server/commands/ExecuteCommand.java
+++ b/src/main/java/net/minecraft/server/commands/ExecuteCommand.java
@@ -232,7 +232,7 @@ public class ExecuteCommand {
         }, CALLBACK_CHAINER);
     }
 
-    private static ArgumentBuilder<CommandSourceStack, ?> addConditionals(CommandNode<CommandSourceStack> root, LiteralArgumentBuilder<CommandSourceStack> argumentBuilder, boolean positive) {
+    static ArgumentBuilder<CommandSourceStack, ?> addConditionals(CommandNode<CommandSourceStack> root, LiteralArgumentBuilder<CommandSourceStack> argumentBuilder, boolean positive) {
         argumentBuilder.then(Commands.literal("block").then(Commands.argument("pos", BlockPosArgument.blockPos()).then(addConditional(root, Commands.argument("block", BlockPredicateArgument.blockPredicate()), positive, (context) -> {
             return BlockPredicateArgument.getBlockPredicate(context, "block").test(new BlockInWorld(context.getSource().getLevel(), BlockPosArgument.getLoadedBlockPos(context, "pos"), true));
         })))).then(Commands.literal("score").then(Commands.argument("target", ScoreHolderArgument.scoreHolder()).suggests(ScoreHolderArgument.SUGGEST_SCORE_HOLDERS).then(Commands.argument("targetObjective", ObjectiveArgument.objective()).then(Commands.literal("=").then(Commands.argument("source", ScoreHolderArgument.scoreHolder()).suggests(ScoreHolderArgument.SUGGEST_SCORE_HOLDERS).then(addConditional(root, Commands.argument("sourceObjective", ObjectiveArgument.objective()), positive, (context) -> {
diff --git a/src/main/java/net/minecraft/server/commands/RunCommand.java b/src/main/java/net/minecraft/server/commands/RunCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..51c821ad9fb0bc61ab2cb997bb0d7a649a227f52
--- /dev/null
+++ b/src/main/java/net/minecraft/server/commands/RunCommand.java
@@ -0,0 +1,95 @@
+package net.minecraft.server.commands;
+
+import com.google.common.collect.Lists;
+import com.mojang.brigadier.CommandDispatcher;
+import com.mojang.brigadier.tree.LiteralCommandNode;
+import java.util.List;
+import net.minecraft.commands.CommandFunction;
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.commands.Commands;
+import net.minecraft.commands.arguments.CodeBlockArgument;
+import net.minecraft.commands.arguments.DimensionArgument;
+import net.minecraft.commands.arguments.EntityAnchorArgument;
+import net.minecraft.commands.arguments.EntityArgument;
+import net.minecraft.commands.arguments.coordinates.RotationArgument;
+import net.minecraft.commands.arguments.coordinates.SwizzleArgument;
+import net.minecraft.commands.arguments.coordinates.Vec3Argument;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.entity.Entity;
+
+// Monumenta: added this command
+// Code is copied from ExecuteCommand, with the 'store' and 'run' arguments removed (and the command name changed to 'run')
+// The only new code is after the comment 'custom code starts here' near the end
+public class RunCommand {
+
+    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
+        LiteralCommandNode<CommandSourceStack> literalCommandNode = dispatcher.register(Commands.literal("run").requires((source) -> {
+            return source.hasPermission(2);
+        }));
+        dispatcher.register(Commands.literal("run").requires((source) -> {
+            return source.hasPermission(2);
+        }).then(ExecuteCommand.addConditionals(literalCommandNode, Commands.literal("if"), true)).then(ExecuteCommand.addConditionals(literalCommandNode, Commands.literal("unless"), false)).then(Commands.literal("as").then(Commands.argument("targets", EntityArgument.entities()).fork(literalCommandNode, (context) -> {
+            List<CommandSourceStack> list = Lists.newArrayList();
+
+            for(Entity entity : EntityArgument.getOptionalEntities(context, "targets")) {
+                list.add(context.getSource().withEntity(entity));
+            }
+
+            return list;
+        }))).then(Commands.literal("at").then(Commands.argument("targets", EntityArgument.entities()).fork(literalCommandNode, (context) -> {
+            List<CommandSourceStack> list = Lists.newArrayList();
+
+            for(Entity entity : EntityArgument.getOptionalEntities(context, "targets")) {
+                list.add(context.getSource().withLevel((ServerLevel)entity.level).withPosition(entity.position()).withRotation(entity.getRotationVector()));
+            }
+
+            return list;
+        }))).then(Commands.literal("positioned").then(Commands.argument("pos", Vec3Argument.vec3()).redirect(literalCommandNode, (context) -> {
+            return context.getSource().withPosition(Vec3Argument.getVec3(context, "pos")).withAnchor(EntityAnchorArgument.Anchor.FEET);
+        })).then(Commands.literal("as").then(Commands.argument("targets", EntityArgument.entities()).fork(literalCommandNode, (context) -> {
+            List<CommandSourceStack> list = Lists.newArrayList();
+
+            for(Entity entity : EntityArgument.getOptionalEntities(context, "targets")) {
+                list.add(context.getSource().withPosition(entity.position()));
+            }
+
+            return list;
+        })))).then(Commands.literal("rotated").then(Commands.argument("rot", RotationArgument.rotation()).redirect(literalCommandNode, (context) -> {
+            return context.getSource().withRotation(RotationArgument.getRotation(context, "rot").getRotation(context.getSource()));
+        })).then(Commands.literal("as").then(Commands.argument("targets", EntityArgument.entities()).fork(literalCommandNode, (context) -> {
+            List<CommandSourceStack> list = Lists.newArrayList();
+
+            for(Entity entity : EntityArgument.getOptionalEntities(context, "targets")) {
+                list.add(context.getSource().withRotation(entity.getRotationVector()));
+            }
+
+            return list;
+        })))).then(Commands.literal("facing").then(Commands.literal("entity").then(Commands.argument("targets", EntityArgument.entities()).then(Commands.argument("anchor", EntityAnchorArgument.anchor()).fork(literalCommandNode, (context) -> {
+            List<CommandSourceStack> list = Lists.newArrayList();
+            EntityAnchorArgument.Anchor anchor = EntityAnchorArgument.getAnchor(context, "anchor");
+
+            for(Entity entity : EntityArgument.getOptionalEntities(context, "targets")) {
+                list.add(context.getSource().facing(entity, anchor));
+            }
+
+            return list;
+        })))).then(Commands.argument("pos", Vec3Argument.vec3()).redirect(literalCommandNode, (context) -> {
+            return context.getSource().facing(Vec3Argument.getVec3(context, "pos"));
+        }))).then(Commands.literal("align").then(Commands.argument("axes", SwizzleArgument.swizzle()).redirect(literalCommandNode, (context) -> {
+            return context.getSource().withPosition(context.getSource().getPosition().align(SwizzleArgument.getSwizzle(context, "axes")));
+        }))).then(Commands.literal("anchored").then(Commands.argument("anchor", EntityAnchorArgument.anchor()).redirect(literalCommandNode, (context) -> {
+            return context.getSource().withAnchor(EntityAnchorArgument.getAnchor(context, "anchor"));
+        }))).then(Commands.literal("in").then(Commands.argument("dimension", DimensionArgument.dimension()).redirect(literalCommandNode, (context) -> {
+            return context.getSource().withLevel(DimensionArgument.getDimension(context, "dimension"));
+        })))
+
+        // custom code starts here
+		.then(Commands.literal("{").then(Commands.argument("code block", CodeBlockArgument.codeBlock())
+		.executes((context) -> {
+			CommandFunction codeBlock = CodeBlockArgument.getCodeBlock(context, "code block");
+			context.getSource().getServer().getFunctions().execute(codeBlock, context.getSource());
+			return 0;
+		}))));
+    }
+
+}
